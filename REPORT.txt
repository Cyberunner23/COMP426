Alex Frappier Lachapelle 40019133


This project uses GLFW instead of GLUT as the library since I am more comfortable with it.

The main thread starts by creating the window. It then initializes a certain amount of balls defined by the command like argument.
The balls are created with random position, velocity, mass and color.
When the ball is created, there is a check to see if it collides with any other ball, if it is the case, a new random ball is generated until no collision is detected.

The main thread then goes into the main loop.
It starts by doing frame limiting that is done by comparing the frame start times between the current frame and the previous frame.
The main thread then sleep until the total frame time elapsed is 1/30 of a second.

The main thread then does the updating using a tbb parallel_for.
The class used for this parallel for is named TbbUpdateBall.

The main thread then does the collision handling. This handling is done in a nested for loop in which each nesting level is done with a parallel_for.
The outer for loop does the wall collision, then calls the tbb parallel_for to do the ball ball collision with the rest of the elements in the vector.
The class used for the outer loop is named TbbWallCollision.
The class used for the inner loop is named TbbBallBallCollision.
The actual collision calculation uses elastic collision formulas.

After that it renders the balls based on their position and color.

A note on the additional files.

GLUtils.hpp:
  This file contains utilities I have created for drawing the background and the circle.
  These functions could have been put in the main file but I put them there for cleanliness.

BallUtils.hpp:
  This file contains utilities I created for the balls themselves. \
  It contains the data representing the ball, ball collision detection, ball generation as well as the update function used in the threads.
